{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "view-in-github",
        "colab_type": "text"
      },
      "source": [
        "<a href=\"https://colab.research.google.com/github/orienz/nng/blob/master/throughput\" target=\"_parent\"><img src=\"https://colab.research.google.com/assets/colab-badge.svg\" alt=\"Open In Colab\"/></a>"
      ]
    },
    {
      "cell_type": "markdown",
      "source": [
        "Okay, here is the Python code for the BLE throughput testing application, structured into modules, along with a `README.md` file.\n",
        "\n",
        "***\n",
        "\n",
        "### `constants.py`"
      ],
      "metadata": {
        "id": "cn6QTkurL0PZ"
      }
    },
    {
      "cell_type": "code",
      "source": [
        "# constants.py\n",
        "\n",
        "# Service and Characteristic UUIDs\n",
        "SERVICE_UUID = \"0000ffff-0000-1000-8000-00805f9b34fb\"\n",
        "CHARACTERISTIC_UUID = \"0000ff01-0000-1000-8000-00805f9b34fb\"\n",
        "\n",
        "# BlueZ D-Bus details\n",
        "BLUEZ_SERVICE = \"org.bluez\"\n",
        "ADAPTER_INTERFACE = f\"{BLUEZ_SERVICE}.Adapter1\"\n",
        "DEVICE_INTERFACE = f\"{BLUEZ_SERVICE}.Device1\"\n",
        "GATT_MANAGER_INTERFACE = f\"{BLUEZ_SERVICE}.GattManager1\"\n",
        "GATT_SERVICE_INTERFACE = f\"{BLUEZ_SERVICE}.GattService1\"\n",
        "GATT_CHARACTERISTIC_INTERFACE = f\"{BLUEZ_SERVICE}.GattCharacteristic1\"\n",
        "LE_ADVERTISING_MANAGER_INTERFACE = f\"{BLUEZ_SERVICE}.LEAdvertisingManager1\"\n",
        "LE_ADVERTISEMENT_INTERFACE = f\"{BLUEZ_SERVICE}.LEAdvertisement1\"\n",
        "\n",
        "# Throughput test parameters\n",
        "TEST_DURATION_SECONDS = 5\n",
        "PACKET_SIZE = 244 # Max ATT MTU - 3 bytes header\n",
        "\n",
        "# Object paths\n",
        "BUS_NAME = BLUEZ_SERVICE\n",
        "APP_PATH = '/org/bluez/example/app'\n",
        "SERVICE_PATH = f\"{APP_PATH}/service0\"\n",
        "CHARACTERISTIC_PATH = f\"{SERVICE_PATH}/char0\"\n",
        "ADV_PATH = '/org/bluez/example/advertisement0'"
      ],
      "outputs": [],
      "execution_count": 1,
      "metadata": {
        "id": "JQ_ra2-uL0Pp"
      }
    },
    {
      "cell_type": "markdown",
      "source": [
        "***\n",
        "\n",
        "### `utils.py`"
      ],
      "metadata": {
        "id": "73poB0HiL0Pz"
      }
    },
    {
      "cell_type": "code",
      "source": [
        "# utils.py\n",
        "import array\n",
        "from pydbus import SystemBus\n",
        "from constants import (\n",
        "    BLUEZ_SERVICE, ADAPTER_INTERFACE, DEVICE_INTERFACE,\n",
        "    GATT_SERVICE_INTERFACE, GATT_CHARACTERISTIC_INTERFACE\n",
        ")\n",
        "\n",
        "def get_bus():\n",
        "    \"\"\"Get the system D-Bus.\"\"\"\n",
        "    return SystemBus()\n",
        "\n",
        "def find_adapter(bus):\n",
        "    \"\"\"Find the default Bluetooth adapter.\"\"\"\n",
        "    remote_om = bus.get(BLUEZ_SERVICE, '/')\n",
        "    objects = remote_om.GetManagedObjects()\n",
        "    for path, ifaces in objects.items():\n",
        "        if ADAPTER_INTERFACE in ifaces:\n",
        "            return bus.get(BLUEZ_SERVICE, path)\n",
        "    return None\n",
        "\n",
        "def find_device(bus, adapter_path, device_address):\n",
        "    \"\"\"Find a device by address.\"\"\"\n",
        "    remote_om = bus.get(BLUEZ_SERVICE, '/')\n",
        "    objects = remote_om.GetManagedObjects()\n",
        "    for path, ifaces in objects.items():\n",
        "        if DEVICE_INTERFACE in ifaces:\n",
        "            if ifaces[DEVICE_INTERFACE]['Address'] == device_address and \\\n",
        "               ifaces[DEVICE_INTERFACE]['Adapter'] == adapter_path:\n",
        "                return bus.get(BLUEZ_SERVICE, path)\n",
        "    return None\n",
        "\n",
        "def find_characteristic_path(bus, device_path, service_uuid, char_uuid):\n",
        "    \"\"\"Find the D-Bus path for a specific characteristic.\"\"\"\n",
        "    remote_om = bus.get(BLUEZ_SERVICE, '/')\n",
        "    objects = remote_om.GetManagedObjects()\n",
        "    device_obj = bus.get(BLUEZ_SERVICE, device_path)\n",
        "\n",
        "    # Ensure services are resolved\n",
        "    if not device_obj.ServicesResolved:\n",
        "        print(\"Services not resolved yet. Waiting...\")\n",
        "        # In a real app, might need a loop or signal wait here\n",
        "        # For simplicity, assuming services resolve quickly after connect\n",
        "        import time\n",
        "        time.sleep(5) # Give some time for service discovery\n",
        "        if not device_obj.ServicesResolved:\n",
        "            print(\"Warning: Services still not resolved.\")\n",
        "\n",
        "\n",
        "    for path, ifaces in objects.items():\n",
        "        if GATT_CHARACTERISTIC_INTERFACE in ifaces and path.startswith(device_path + \"/\"):\n",
        "            char_props = ifaces[GATT_CHARACTERISTIC_INTERFACE]\n",
        "            if char_props['UUID'].lower() == char_uuid.lower():\n",
        "                # Now check if the parent service UUID matches\n",
        "                service_path = '/'.join(path.split('/')[:-1])\n",
        "                if GATT_SERVICE_INTERFACE in objects.get(service_path, {}):\n",
        "                    service_props = objects[service_path][GATT_SERVICE_INTERFACE]\n",
        "                    if service_props['UUID'].lower() == service_uuid.lower():\n",
        "                        return path\n",
        "    return None\n",
        "\n",
        "def bytes_to_dbus_array(byte_list):\n",
        "    \"\"\"Convert a list of Python integers (0-255) to a D-Bus byte array.\"\"\"\n",
        "    return array.array('y', byte_list).tolist()"
      ],
      "outputs": [
        {
          "output_type": "error",
          "ename": "ModuleNotFoundError",
          "evalue": "No module named 'pydbus'",
          "traceback": [
            "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
            "\u001b[0;31mModuleNotFoundError\u001b[0m                       Traceback (most recent call last)",
            "\u001b[0;32m<ipython-input-4-680ab977604a>\u001b[0m in \u001b[0;36m<cell line: 0>\u001b[0;34m()\u001b[0m\n\u001b[1;32m      1\u001b[0m \u001b[0;31m# utils.py\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m      2\u001b[0m \u001b[0;32mimport\u001b[0m \u001b[0marray\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m----> 3\u001b[0;31m \u001b[0;32mfrom\u001b[0m \u001b[0mpydbus\u001b[0m \u001b[0;32mimport\u001b[0m \u001b[0mSystemBus\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m      4\u001b[0m from constants import (\n\u001b[1;32m      5\u001b[0m     \u001b[0mBLUEZ_SERVICE\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mADAPTER_INTERFACE\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mDEVICE_INTERFACE\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
            "\u001b[0;31mModuleNotFoundError\u001b[0m: No module named 'pydbus'",
            "",
            "\u001b[0;31m---------------------------------------------------------------------------\u001b[0;32m\nNOTE: If your import is failing due to a missing package, you can\nmanually install dependencies using either !pip or !apt.\n\nTo view examples of installing some common dependencies, click the\n\"Open Examples\" button below.\n\u001b[0;31m---------------------------------------------------------------------------\u001b[0m\n"
          ],
          "errorDetails": {
            "actions": [
              {
                "action": "open_url",
                "actionText": "Open Examples",
                "url": "/notebooks/snippets/importing_libraries.ipynb"
              }
            ]
          }
        }
      ],
      "execution_count": 4,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/",
          "height": 383
        },
        "id": "iGpQR39iL0P2",
        "outputId": "34a9b2f2-9741-4917-d18f-7471e447a739"
      }
    },
    {
      "cell_type": "markdown",
      "source": [
        "***\n",
        "\n",
        "### `peripheral.py`"
      ],
      "metadata": {
        "id": "ApaEZGYnL0P5"
      }
    },
    {
      "cell_type": "code",
      "source": [
        "# peripheral.py\n",
        "import threading\n",
        "import time\n",
        "from gi.repository import GLib\n",
        "from pydbus.generic import signal\n",
        "from pydbus import SystemBus\n",
        "\n",
        "from constants import (\n",
        "    BLUEZ_SERVICE, ADAPTER_INTERFACE, GATT_MANAGER_INTERFACE,\n",
        "    GATT_SERVICE_INTERFACE, GATT_CHARACTERISTIC_INTERFACE,\n",
        "    LE_ADVERTISING_MANAGER_INTERFACE, LE_ADVERTISEMENT_INTERFACE,\n",
        "    SERVICE_UUID, CHARACTERISTIC_UUID, PACKET_SIZE,\n",
        "    BUS_NAME, APP_PATH, SERVICE_PATH, CHARACTERISTIC_PATH, ADV_PATH\n",
        ")\n",
        "from utils import find_adapter, bytes_to_dbus_array\n",
        "\n",
        "class Application:\n",
        "    \"\"\"\n",
        "    org.bluez.GattApplication1 interface implementation\n",
        "    \"\"\"\n",
        "    def __init__(self, bus):\n",
        "        self.path = APP_PATH\n",
        "        self.services = []\n",
        "        self.bus = bus\n",
        "\n",
        "    def add_service(self, service):\n",
        "        self.services.append(service)\n",
        "\n",
        "    def get_path(self):\n",
        "        return self.path\n",
        "\n",
        "    def get_bus(self):\n",
        "        return self.bus\n",
        "\n",
        "    def GetManagedObjects(self):\n",
        "        response = {}\n",
        "        for service in self.services:\n",
        "            response[service.get_path()] = service.get_properties()\n",
        "            chrcs = service.get_characteristics()\n",
        "            for chrc in chrcs:\n",
        "                response[chrc.get_path()] = chrc.get_properties()\n",
        "                # Descriptors can be added here if needed\n",
        "        return response\n",
        "\n",
        "class Service:\n",
        "    \"\"\"\n",
        "    org.bluez.GattService1 interface implementation\n",
        "    \"\"\"\n",
        "    def __init__(self, bus, index, uuid, primary):\n",
        "        self.path = f\"{APP_PATH}/service{index}\"\n",
        "        self.bus = bus\n",
        "        self.uuid = uuid\n",
        "        self.primary = primary\n",
        "        self.characteristics = []\n",
        "\n",
        "    def add_characteristic(self, characteristic):\n",
        "        self.characteristics.append(characteristic)\n",
        "\n",
        "    def get_properties(self):\n",
        "        return {\n",
        "            GATT_SERVICE_INTERFACE: {\n",
        "                'UUID': self.uuid,\n",
        "                'Primary': self.primary,\n",
        "                'Characteristics': [chrc.get_path() for chrc in self.characteristics]\n",
        "            }\n",
        "        }\n",
        "\n",
        "    def get_path(self):\n",
        "        return self.path\n",
        "\n",
        "    def get_characteristics(self):\n",
        "        return self.characteristics\n",
        "\n",
        "class Characteristic:\n",
        "    \"\"\"\n",
        "    org.bluez.GattCharacteristic1 interface implementation\n",
        "    \"\"\"\n",
        "    PropertiesChanged = signal()\n",
        "\n",
        "    def __init__(self, bus, index, uuid, flags, service):\n",
        "        self.path = f\"{service.path}/char{index}\"\n",
        "        self.bus = bus\n",
        "        self.uuid = uuid\n",
        "        self.service = service\n",
        "        self.flags = flags\n",
        "        self.value = []\n",
        "        self.notifying = False\n",
        "        self.bytes_received = 0\n",
        "        self.start_time = None\n",
        "        self.last_print_time = 0\n",
        "\n",
        "    def get_properties(self):\n",
        "        return {\n",
        "            GATT_CHARACTERISTIC_INTERFACE: {\n",
        "                'Service': self.service.get_path(),\n",
        "                'UUID': self.uuid,\n",
        "                'Flags': self.flags,\n",
        "                'Value': self.value, # ReadValue uses this\n",
        "                'Notifying': self.notifying\n",
        "                # 'Descriptors': [] # Add descriptor paths here if any\n",
        "            }\n",
        "        }\n",
        "\n",
        "    def get_path(self):\n",
        "        return self.path\n",
        "\n",
        "    def ReadValue(self, options):\n",
        "        # In this throughput test, we don't expect reads, but implement basic\n",
        "        print(f\"Read request received on {self.path}\")\n",
        "        return self.value\n",
        "\n",
        "    def WriteValue(self, value, options):\n",
        "        # This is the core of the peripheral throughput test\n",
        "        if self.start_time is None:\n",
        "            self.start_time = time.monotonic()\n",
        "            print(\"Receiving data...\")\n",
        "\n",
        "        received_len = len(value)\n",
        "        self.bytes_received += received_len\n",
        "        # self.value = value # Optional: Store the last written value\n",
        "\n",
        "        current_time = time.monotonic()\n",
        "        elapsed_time = current_time - self.start_time\n",
        "\n",
        "        # Print progress roughly every second\n",
        "        if current_time - self.last_print_time >= 1.0:\n",
        "             if elapsed_time > 0:\n",
        "                speed_bps = (self.bytes_received * 8) / elapsed_time\n",
        "                speed_kbps = speed_bps / 1000\n",
        "                print(f\"-> Received: {self.bytes_received} bytes in {elapsed_time:.2f}s ({speed_kbps:.2f} kbps)\")\n",
        "             self.last_print_time = current_time\n",
        "\n",
        "\n",
        "    # --- Methods required by pydbus for properties ---\n",
        "    @property\n",
        "    def Value(self):\n",
        "        return self.value\n",
        "\n",
        "    @Value.setter\n",
        "    def Value(self, value):\n",
        "        # This might be called internally by pydbus or BlueZ, but WriteValue is primary\n",
        "        self.value = value\n",
        "        # Could emit PropertiesChanged if needed\n",
        "\n",
        "    @property\n",
        "    def Notifying(self):\n",
        "        return self.notifying\n",
        "\n",
        "    # --- Notification methods (not used in this specific test) ---\n",
        "    def StartNotify(self):\n",
        "        if self.notifying:\n",
        "            print('Already notifying, nothing to do')\n",
        "            return\n",
        "\n",
        "        print('StartNotify called')\n",
        "        self.notifying = True\n",
        "        # In a real app, you'd start sending notifications here\n",
        "        # Example: self.PropertiesChanged(GATT_CHARACTERISTIC_INTERFACE, {'Value': new_value}, [])\n",
        "\n",
        "    def StopNotify(self):\n",
        "        if not self.notifying:\n",
        "            print('Not notifying, nothing to do')\n",
        "            return\n",
        "\n",
        "        print('StopNotify called')\n",
        "        self.notifying = False\n",
        "        # Stop sending notifications\n",
        "\n",
        "\n",
        "class Advertisement:\n",
        "    \"\"\"\n",
        "    org.bluez.LEAdvertisement1 interface implementation\n",
        "    \"\"\"\n",
        "    def __init__(self, bus, index):\n",
        "        self.path = f\"{ADV_PATH}\"\n",
        "        self.bus = bus\n",
        "        self.index = index\n",
        "        self.service_uuids = [SERVICE_UUID]\n",
        "        self.manufacturer_data = {} # Example: {0xffff: [0x70, 0x71]}\n",
        "        self.solicit_uuids = []\n",
        "        self.service_data = {} # Example: {'9999': [0x00, 0x01, ...]}\n",
        "        self.include_tx_power = True\n",
        "        self.local_name = \"BLE_Throughput_Test\" # Advertise a recognizable name\n",
        "        self.appearance = 0 # Unknown or Generic\n",
        "        # self.duration = 0 # Advertise indefinitely\n",
        "        # self.timeout = 0 # No timeout\n",
        "\n",
        "    def get_properties(self):\n",
        "        props = {\n",
        "            'Type': 'peripheral',\n",
        "            'ServiceUUIDs': self.service_uuids,\n",
        "            'ManufacturerData': self.manufacturer_data,\n",
        "            'SolicitUUIDs': self.solicit_uuids,\n",
        "            'ServiceData': self.service_data,\n",
        "            'IncludeTxPower': self.include_tx_power,\n",
        "            'LocalName': self.local_name,\n",
        "            'Appearance': self.appearance,\n",
        "            # 'Duration': self.duration, # Not always available/settable\n",
        "            # 'Timeout': self.timeout, # Not always available/settable\n",
        "        }\n",
        "        return {LE_ADVERTISEMENT_INTERFACE: props}\n",
        "\n",
        "    def get_path(self):\n",
        "        return self.path\n",
        "\n",
        "    def Release(self):\n",
        "        \"\"\"Called when advertisement is unregistered.\"\"\"\n",
        "        print(f\"{self.path} Released\")\n",
        "\n",
        "# Global peripheral state\n",
        "mainloop = None\n",
        "gatt_app = None\n",
        "adapter = None\n",
        "adv_manager = None\n",
        "ad = None\n",
        "bus = None\n",
        "characteristic_instance = None # Keep track of the characteristic instance\n",
        "\n",
        "def register_app_cb():\n",
        "    print(\"GATT application registered\")\n",
        "\n",
        "def register_app_error_cb(error):\n",
        "    print(f\"Failed to register application: {error}\")\n",
        "    if mainloop:\n",
        "        mainloop.quit()\n",
        "\n",
        "def register_ad_cb():\n",
        "    print(\"Advertisement registered\")\n",
        "    print(f\"Peripheral started. Waiting for connections on service {SERVICE_UUID}...\")\n",
        "\n",
        "def register_ad_error_cb(error):\n",
        "    print(f\"Failed to register advertisement: {error}\")\n",
        "    # If Adv fails, try to unregister the GATT app too\n",
        "    try:\n",
        "        if gatt_app and adapter:\n",
        "            gatt_manager = bus.get(BLUEZ_SERVICE, adapter.path)[GATT_MANAGER_INTERFACE]\n",
        "            gatt_manager.UnregisterApplication(gatt_app.get_path())\n",
        "            print(\"Attempted to unregister GATT application.\")\n",
        "    except Exception as e:\n",
        "        print(f\"Error during cleanup after advertisement failure: {e}\")\n",
        "    finally:\n",
        "        if mainloop:\n",
        "            mainloop.quit()\n",
        "\n",
        "def run_peripheral_mode():\n",
        "    global mainloop, gatt_app, adapter, adv_manager, ad, bus, characteristic_instance\n",
        "    # Set up D-Bus connection and GLib main loop\n",
        "    GLib.threads_init()\n",
        "    bus = SystemBus()\n",
        "    mainloop = GLib.MainLoop()\n",
        "\n",
        "    # Get adapter and interfaces\n",
        "    adapter = find_adapter(bus)\n",
        "    if not adapter:\n",
        "        print(\"Error: Bluetooth adapter not found.\")\n",
        "        return\n",
        "\n",
        "    try:\n",
        "        gatt_manager = bus.get(BLUEZ_SERVICE, adapter.path)[GATT_MANAGER_INTERFACE]\n",
        "        adv_manager = bus.get(BLUEZ_SERVICE, adapter.path)[LE_ADVERTISING_MANAGER_INTERFACE]\n",
        "    except KeyError:\n",
        "         print(f\"Error: GATT Manager or LE Advertising Manager not found on {adapter.path}.\")\n",
        "         print(\"Ensure Bluetooth daemon is running and supports these features.\")\n",
        "         return\n",
        "    except Exception as e:\n",
        "         print(f\"Error accessing BlueZ interfaces: {e}\")\n",
        "         return\n",
        "\n",
        "\n",
        "    # Create application, service, characteristic\n",
        "    gatt_app = Application(bus)\n",
        "    service = Service(bus, 0, SERVICE_UUID, True) # Primary service\n",
        "    # Characteristic allows write without response ('write-without-response')\n",
        "    # Also allow 'write' for compatibility/testing if needed.\n",
        "    characteristic_instance = Characteristic(bus, 0, CHARACTERISTIC_UUID, ['write', 'write-without-response'], service)\n",
        "    service.add_characteristic(characteristic_instance)\n",
        "    gatt_app.add_service(service)\n",
        "\n",
        "    # Create advertisement\n",
        "    ad = Advertisement(bus, 0)\n",
        "\n",
        "    # Publish application and services over D-Bus\n",
        "    # This makes them discoverable by BlueZ\n",
        "    bus.publish(APP_PATH, gatt_app)\n",
        "    bus.publish(SERVICE_PATH, service)\n",
        "    bus.publish(CHARACTERISTIC_PATH, characteristic_instance)\n",
        "    bus.publish(ADV_PATH, ad) # Publish advertisement object\n",
        "\n",
        "    # Register the GATT application with BlueZ\n",
        "    print(\"Registering GATT application...\")\n",
        "    gatt_manager.RegisterApplication(\n",
        "        gatt_app.get_path(),\n",
        "        {}, # Options dictionary (e.g., {'Version': dbus.UInt16(512)})\n",
        "        reply_handler=register_app_cb,\n",
        "        error_handler=register_app_error_cb\n",
        "    )\n",
        "\n",
        "    # Register the advertisement with BlueZ\n",
        "    print(\"Registering advertisement...\")\n",
        "    adv_manager.RegisterAdvertisement(\n",
        "        ad.get_path(),\n",
        "        {}, # Options dictionary\n",
        "        reply_handler=register_ad_cb,\n",
        "        error_handler=register_ad_error_cb\n",
        "    )\n",
        "\n",
        "    try:\n",
        "        # Run the main loop to handle D-Bus messages (like WriteValue)\n",
        "        mainloop.run()\n",
        "    except KeyboardInterrupt:\n",
        "        print(\"\\nKeyboard interrupt received. Cleaning up...\")\n",
        "    finally:\n",
        "        # Cleanup on exit\n",
        "        print(\"Unregistering...\")\n",
        "        try:\n",
        "            if ad and adv_manager:\n",
        "                print(f\"Unregistering advertisement: {ad.get_path()}\")\n",
        "                adv_manager.UnregisterAdvertisement(ad.get_path())\n",
        "                bus.unpublish(ad.get_path()) # Unpublish advertisement object\n",
        "        except Exception as e:\n",
        "            print(f\"Error unregistering advertisement: {e}\")\n",
        "\n",
        "        try:\n",
        "             if gatt_app and gatt_manager:\n",
        "                print(f\"Unregistering application: {gatt_app.get_path()}\")\n",
        "                gatt_manager.UnregisterApplication(gatt_app.get_path())\n",
        "                # Unpublish app/service/char objects\n",
        "                bus.unpublish(characteristic_instance.get_path())\n",
        "                bus.unpublish(service.get_path())\n",
        "                bus.unpublish(gatt_app.get_path())\n",
        "\n",
        "        except Exception as e:\n",
        "            print(f\"Error unregistering application: {e}\")\n",
        "\n",
        "        print(\"Peripheral stopped.\")\n",
        "\n",
        "if __name__ == '__main__':\n",
        "    # This allows running peripheral mode directly for testing\n",
        "    print(\"Starting peripheral mode standalone...\")\n",
        "    run_peripheral_mode()"
      ],
      "outputs": [],
      "execution_count": null,
      "metadata": {
        "id": "g6QTU-s3L0P6"
      }
    },
    {
      "cell_type": "markdown",
      "source": [
        "***\n",
        "\n",
        "### `central.py`"
      ],
      "metadata": {
        "id": "T_C7xNj4L0QA"
      }
    },
    {
      "cell_type": "code",
      "source": [
        "# central.py\n",
        "import asyncio\n",
        "import time\n",
        "import array\n",
        "from pydbus import SystemBus\n",
        "\n",
        "from constants import (\n",
        "    BLUEZ_SERVICE, ADAPTER_INTERFACE, DEVICE_INTERFACE,\n",
        "    GATT_CHARACTERISTIC_INTERFACE,\n",
        "    SERVICE_UUID, CHARACTERISTIC_UUID,\n",
        "    PACKET_SIZE, TEST_DURATION_SECONDS\n",
        ")\n",
        "from utils import find_adapter, find_device, find_characteristic_path, bytes_to_dbus_array\n",
        "\n",
        "async def list_paired_devices(bus, adapter_path):\n",
        "    \"\"\"List paired Bluetooth devices.\"\"\"\n",
        "    print(\"Scanning for paired devices...\")\n",
        "    remote_om = bus.get(BLUEZ_SERVICE, '/')\n",
        "    objects = remote_om.GetManagedObjects()\n",
        "    devices = []\n",
        "    adapter_proxy = bus.get(BLUEZ_SERVICE, adapter_path)\n",
        "\n",
        "    for path, ifaces in objects.items():\n",
        "        if DEVICE_INTERFACE in ifaces:\n",
        "            dev_props = ifaces[DEVICE_INTERFACE]\n",
        "            # Check if the device belongs to the adapter we are using\n",
        "            # And if it's paired or connected\n",
        "            if dev_props.get('Adapter') == adapter_path and \\\n",
        "               (dev_props.get('Paired', False) or dev_props.get('Connected', False)):\n",
        "                devices.append({\n",
        "                    'path': path,\n",
        "                    'name': dev_props.get('Alias', dev_props.get('Name', 'Unknown Device')),\n",
        "                    'address': dev_props['Address'],\n",
        "                    'paired': dev_props.get('Paired', False),\n",
        "                    'connected': dev_props.get('Connected', False)\n",
        "                })\n",
        "\n",
        "    if not devices:\n",
        "        print(\"No paired or connected devices found for this adapter.\")\n",
        "        print(\"Please pair with the target device first using bluetoothctl or system settings.\")\n",
        "        return None\n",
        "\n",
        "    print(\"\\nAvailable Paired/Connected Devices:\")\n",
        "    for i, dev in enumerate(devices):\n",
        "        status = []\n",
        "        if dev['paired']: status.append(\"Paired\")\n",
        "        if dev['connected']: status.append(\"Connected\")\n",
        "        print(f\"  {i}: {dev['name']} ({dev['address']}) [{' '.join(status)}]\")\n",
        "\n",
        "    while True:\n",
        "        try:\n",
        "            choice = input(\"Select device index to connect: \")\n",
        "            selected_device = devices[int(choice)]\n",
        "            return selected_device\n",
        "        except (ValueError, IndexError):\n",
        "            print(\"Invalid choice. Please enter a valid index.\")\n",
        "        except EOFError:\n",
        "            print(\"\\nOperation cancelled.\")\n",
        "            return None\n",
        "\n",
        "\n",
        "async def list_services_characteristics(bus, device_path):\n",
        "    \"\"\"List services and characteristics of a connected device.\"\"\"\n",
        "    print(f\"\\nDiscovering services and characteristics for device: {device_path}\")\n",
        "    device_proxy = bus.get(BLUEZ_SERVICE, device_path)\n",
        "\n",
        "    # Ensure device is connected\n",
        "    if not device_proxy.Connected:\n",
        "        print(\"Device is not connected. Attempting to connect...\")\n",
        "        try:\n",
        "            await asyncio.to_thread(device_proxy.Connect) # Use asyncio.to_thread for sync D-Bus call\n",
        "            print(\"Connected successfully.\")\n",
        "            # Wait a bit for services to be resolved after connection\n",
        "            await asyncio.sleep(5)\n",
        "        except Exception as e:\n",
        "            print(f\"Connection failed: {e}\")\n",
        "            # Check if already connected (race condition)\n",
        "            if not device_proxy.Connected:\n",
        "                 return False\n",
        "\n",
        "    # Check if services are resolved\n",
        "    if not device_proxy.ServicesResolved:\n",
        "        print(\"Services not yet resolved. Waiting...\")\n",
        "        # Ideally, wait for PropertiesChanged signal, but sleep is simpler here\n",
        "        await asyncio.sleep(5) # Give BlueZ time\n",
        "        if not device_proxy.ServicesResolved:\n",
        "            print(\"Warning: Services still not resolved after waiting.\")\n",
        "            # Proceed anyway, but listing might fail\n",
        "\n",
        "    remote_om = bus.get(BLUEZ_SERVICE, '/')\n",
        "    objects = remote_om.GetManagedObjects()\n",
        "\n",
        "    print(\"\\nServices and Characteristics:\")\n",
        "    found_target = False\n",
        "    for path, ifaces in objects.items():\n",
        "        # Check if the path belongs to the selected device\n",
        "        if path.startswith(device_path + \"/\"):\n",
        "            if GATT_SERVICE_INTERFACE in ifaces:\n",
        "                service_props = ifaces[GATT_SERVICE_INTERFACE]\n",
        "                service_uuid = service_props['UUID']\n",
        "                print(f\"\\n  Service: {service_uuid} ({path})\")\n",
        "                if service_uuid.lower() == SERVICE_UUID.lower():\n",
        "                     print(\"    (Target Service Found)\")\n",
        "\n",
        "                # Look for characteristics within this service path\n",
        "                for char_path, char_ifaces in objects.items():\n",
        "                    if char_path.startswith(path + \"/\") and GATT_CHARACTERISTIC_INTERFACE in char_ifaces:\n",
        "                        char_props = char_ifaces[GATT_CHARACTERISTIC_INTERFACE]\n",
        "                        char_uuid = char_props['UUID']\n",
        "                        flags = \", \".join(char_props['Flags'])\n",
        "                        print(f\"    Characteristic: {char_uuid} [{flags}] ({char_path})\")\n",
        "                        if service_uuid.lower() == SERVICE_UUID.lower() and \\\n",
        "                           char_uuid.lower() == CHARACTERISTIC_UUID.lower():\n",
        "                            print(\"      (Target Characteristic Found)\")\n",
        "                            found_target = True\n",
        "\n",
        "    if not found_target:\n",
        "        print(f\"\\nWarning: Target characteristic {CHARACTERISTIC_UUID} under service {SERVICE_UUID} not found.\")\n",
        "        print(\"Ensure the peripheral is running and advertising the correct service.\")\n",
        "\n",
        "    return True\n",
        "\n",
        "\n",
        "async def run_throughput_test(bus, device_path):\n",
        "    \"\"\"Perform the throughput test by writing data.\"\"\"\n",
        "    print(f\"\\nStarting throughput test to device: {device_path}\")\n",
        "    device_proxy = bus.get(BLUEZ_SERVICE, device_path)\n",
        "\n",
        "    # 1. Ensure connection\n",
        "    if not device_proxy.Connected:\n",
        "        print(\"Device not connected. Attempting to connect...\")\n",
        "        try:\n",
        "            await asyncio.to_thread(device_proxy.Connect)\n",
        "            print(\"Connected successfully.\")\n",
        "            await asyncio.sleep(2) # Allow time for connection stabilization\n",
        "        except Exception as e:\n",
        "            print(f\"Connection failed: {e}\")\n",
        "            # Check if already connected (race condition)\n",
        "            if not device_proxy.Connected:\n",
        "                 return False\n",
        "\n",
        "    # 2. Find the target characteristic D-Bus path\n",
        "    print(f\"Searching for Characteristic UUID: {CHARACTERISTIC_UUID}\")\n",
        "    char_path = await asyncio.to_thread(find_characteristic_path, bus, device_path, SERVICE_UUID, CHARACTERISTIC_UUID)\n",
        "\n",
        "    if not char_path:\n",
        "        print(f\"Error: Could not find characteristic {CHARACTERISTIC_UUID} on the device.\")\n",
        "        print(\"Ensure the peripheral is running the correct GATT service.\")\n",
        "        return False\n",
        "\n",
        "    print(f\"Found target characteristic at path: {char_path}\")\n",
        "    char_proxy = bus.get(BLUEZ_SERVICE, char_path)\n",
        "\n",
        "    # 3. Prepare data packet\n",
        "    # Create a list of bytes (0-255 integers)\n",
        "    data_packet = list(range(PACKET_SIZE))\n",
        "    # Convert to the 'ay' D-Bus type (array of bytes)\n",
        "    dbus_data_packet = bytes_to_dbus_array(data_packet)\n",
        "\n",
        "    # 4. Run the test loop\n",
        "    start_time = time.monotonic()\n",
        "    end_time = start_time + TEST_DURATION_SECONDS\n",
        "    bytes_sent = 0\n",
        "    packets_sent = 0\n",
        "    last_print_time = start_time\n",
        "\n",
        "    print(f\"Sending {PACKET_SIZE}-byte packets for {TEST_DURATION_SECONDS} seconds...\")\n",
        "    try:\n",
        "        while time.monotonic() < end_time:\n",
        "            # Use 'write-without-response' for max throughput\n",
        "            # The peripheral characteristic must support this flag.\n",
        "            options = {'type': 'command'} # 'command' corresponds to Write Without Response\n",
        "\n",
        "            # Run the synchronous D-Bus call in a separate thread\n",
        "            await asyncio.to_thread(char_proxy.WriteValue, dbus_data_packet, options)\n",
        "\n",
        "            bytes_sent += PACKET_SIZE\n",
        "            packets_sent += 1\n",
        "\n",
        "            # Optional: Print progress (can slow down test slightly)\n",
        "            current_time = time.monotonic()\n",
        "            if current_time - last_print_time >= 1.0:\n",
        "                 elapsed_time = current_time - start_time\n",
        "                 if elapsed_time > 0:\n",
        "                    speed_bps = (bytes_sent * 8) / elapsed_time\n",
        "                    speed_kbps = speed_bps / 1000\n",
        "                    print(f\"-> Sent: {bytes_sent} bytes ({packets_sent} packets) in {elapsed_time:.2f}s ({speed_kbps:.2f} kbps)\")\n",
        "                 last_print_time = current_time\n",
        "\n",
        "    except Exception as e:\n",
        "        print(f\"\\nError during write operation: {e}\")\n",
        "        print(\"This might happen if the connection drops or the characteristic doesn't support write-without-response.\")\n",
        "        # Calculate speed based on data sent before the error\n",
        "    finally:\n",
        "        final_elapsed_time = time.monotonic() - start_time\n",
        "        print(\"\\nThroughput Test Finished.\")\n",
        "        if final_elapsed_time > 0:\n",
        "            final_speed_bps = (bytes_sent * 8) / final_elapsed_time\n",
        "            final_speed_kbps = final_speed_bps / 1000\n",
        "            print(f\"Total bytes sent: {bytes_sent}\")\n",
        "            print(f\"Total packets sent: {packets_sent}\")\n",
        "            print(f\"Test duration: {final_elapsed_time:.2f} seconds\")\n",
        "            print(f\"Approximate throughput: {final_speed_kbps:.2f} kbps\")\n",
        "        else:\n",
        "            print(\"Test duration too short to calculate throughput.\")\n",
        "\n",
        "    return True\n",
        "\n",
        "async def run_central_mode():\n",
        "    \"\"\"Main function for central mode operation.\"\"\"\n",
        "    bus = SystemBus()\n",
        "    adapter = find_adapter(bus)\n",
        "    if not adapter:\n",
        "        print(\"Error: Bluetooth adapter not found.\")\n",
        "        return\n",
        "\n",
        "    print(f\"Using adapter: {adapter.path}\")\n",
        "    target_device_info = None\n",
        "    target_device_path = None\n",
        "\n",
        "    while True:\n",
        "        try:\n",
        "            command = input(\"\\nCentral Mode > \").strip().lower().split()\n",
        "            if not command:\n",
        "                continue\n",
        "\n",
        "            action = command[0]\n",
        "\n",
        "            if action == \"list\":\n",
        "                 if not target_device_path:\n",
        "                     target_device_info = await list_paired_devices(bus, adapter.path)\n",
        "                     if target_device_info:\n",
        "                         target_device_path = target_device_info['path']\n",
        "                     else:\n",
        "                          continue # Stay in loop if no device selected/found\n",
        "                 else:\n",
        "                     # If a device is already selected, list its services/chars\n",
        "                      print(f\"Listing services for selected device: {target_device_info['name']} ({target_device_info['address']})\")\n",
        "                      await list_services_characteristics(bus, target_device_path)\n",
        "\n",
        "\n",
        "            elif action == \"select\": # Allow re-selecting a device\n",
        "                target_device_info = await list_paired_devices(bus, adapter.path)\n",
        "                if target_device_info:\n",
        "                    target_device_path = target_device_info['path']\n",
        "                else:\n",
        "                    target_device_path = None # Reset if selection failed\n",
        "\n",
        "            elif action == \"run\":\n",
        "                if not target_device_path:\n",
        "                    print(\"No target device selected. Use 'list' or 'select' first.\")\n",
        "                    # Optionally, run list_paired_devices here automatically\n",
        "                    target_device_info = await list_paired_devices(bus, adapter.path)\n",
        "                    if target_device_info:\n",
        "                        target_device_path = target_device_info['path']\n",
        "                    else:\n",
        "                        continue # Abort run if no device selected\n",
        "\n",
        "                if target_device_path:\n",
        "                    await run_throughput_test(bus, target_device_path)\n",
        "\n",
        "            elif action == \"exit\":\n",
        "                print(\"Exiting central mode.\")\n",
        "                # Disconnect if connected? Optional. BlueZ often handles this.\n",
        "                # if target_device_path:\n",
        "                #     try:\n",
        "                #         device_proxy = bus.get(BLUEZ_SERVICE, target_device_path)\n",
        "                #         if device_proxy.Connected:\n",
        "                #             print(f\"Disconnecting from {target_device_info['name']}...\")\n",
        "                #             await asyncio.to_thread(device_proxy.Disconnect)\n",
        "                #     except Exception as e:\n",
        "                #         print(f\"Error during disconnect: {e}\")\n",
        "                break\n",
        "\n",
        "            else:\n",
        "                print(\"Unknown command. Available: list, select, run, exit\")\n",
        "\n",
        "        except EOFError:\n",
        "            print(\"\\nExiting central mode.\")\n",
        "            break\n",
        "        except Exception as e:\n",
        "            print(f\"\\nAn unexpected error occurred: {e}\")\n",
        "            import traceback\n",
        "            traceback.print_exc() # Print stack trace for debugging\n",
        "\n",
        "if __name__ == '__main__':\n",
        "    # This allows running central mode directly for testing\n",
        "    print(\"Starting central mode standalone...\")\n",
        "    try:\n",
        "        asyncio.run(run_central_mode())\n",
        "    except KeyboardInterrupt:\n",
        "        print(\"\\nOperation cancelled by user.\")"
      ],
      "outputs": [],
      "execution_count": null,
      "metadata": {
        "id": "CrvcGYk7L0QC"
      }
    },
    {
      "cell_type": "markdown",
      "source": [
        "***\n",
        "\n",
        "### `cli.py` (Main application entry point)"
      ],
      "metadata": {
        "id": "AGLUYJK1L0QH"
      }
    },
    {
      "cell_type": "code",
      "source": [
        "#!/usr/bin/env python3\n",
        "# cli.py - Main entry point for the BLE Throughput Tester\n",
        "\n",
        "import sys\n",
        "import asyncio\n",
        "from peripheral import run_peripheral_mode\n",
        "from central import run_central_mode\n",
        "\n",
        "def print_usage():\n",
        "    \"\"\"Prints usage instructions.\"\"\"\n",
        "    print(\"BLE Throughput Tester\")\n",
        "    print(\"Usage: python cli.py [central | peripheral]\")\n",
        "    print(\"\\nRun in interactive mode:\")\n",
        "    print(\"  python cli.py\")\n",
        "    print(\"    > role central  (Switches to central mode interactive commands)\")\n",
        "    print(\"    > role peripheral (Starts peripheral mode and waits for connections)\")\n",
        "    print(\"    > exit          (Exits the application)\")\n",
        "    print(\"\\nCentral Mode Commands (after 'role central'):\")\n",
        "    print(\"  list   - List paired devices and select one, or list services of selected device.\")\n",
        "    print(\"  select - Force re-selection of a paired device.\")\n",
        "    print(\"  run    - Run the throughput test on the selected device.\")\n",
        "    print(\"  exit   - Exit central mode.\")\n",
        "\n",
        "\n",
        "def main():\n",
        "    \"\"\"Main function to handle role selection and start modes.\"\"\"\n",
        "    current_role = None\n",
        "\n",
        "    # Check for command-line argument for direct role start\n",
        "    if len(sys.argv) == 2:\n",
        "        role_arg = sys.argv[1].lower()\n",
        "        if role_arg == \"central\":\n",
        "            print(\"Starting directly in Central mode.\")\n",
        "            try:\n",
        "                asyncio.run(run_central_mode())\n",
        "            except KeyboardInterrupt:\n",
        "                print(\"\\nCentral mode interrupted.\")\n",
        "            return # Exit after central mode finishes\n",
        "        elif role_arg == \"peripheral\":\n",
        "            print(\"Starting directly in Peripheral mode.\")\n",
        "            try:\n",
        "                run_peripheral_mode()\n",
        "            except KeyboardInterrupt:\n",
        "                 print(\"\\nPeripheral mode interrupted.\")\n",
        "            return # Exit after peripheral mode finishes\n",
        "        else:\n",
        "            print(f\"Unknown role: {sys.argv[1]}\")\n",
        "            print_usage()\n",
        "            sys.exit(1)\n",
        "\n",
        "    # Interactive mode if no valid command-line argument\n",
        "    print(\"Starting in interactive mode.\")\n",
        "    while True:\n",
        "        try:\n",
        "            command_line = input(\"\\nMain Menu > \").strip().lower()\n",
        "            if not command_line:\n",
        "                continue\n",
        "\n",
        "            parts = command_line.split()\n",
        "            command = parts[0]\n",
        "\n",
        "            if command == \"role\":\n",
        "                if len(parts) > 1:\n",
        "                    role = parts[1]\n",
        "                    if role == \"central\":\n",
        "                        print(\"Switching to Central mode...\")\n",
        "                        current_role = \"central\"\n",
        "                        # Run the central mode's interactive loop\n",
        "                        try:\n",
        "                            asyncio.run(run_central_mode())\n",
        "                        except KeyboardInterrupt:\n",
        "                             print(\"\\nCentral mode interrupted. Returning to main menu.\")\n",
        "                        current_role = None # Return to main menu state\n",
        "                    elif role == \"peripheral\":\n",
        "                        print(\"Starting Peripheral mode...\")\n",
        "                        current_role = \"peripheral\"\n",
        "                        # Run the peripheral mode (blocks until interrupted/error)\n",
        "                        try:\n",
        "                           run_peripheral_mode()\n",
        "                        except KeyboardInterrupt:\n",
        "                           print(\"\\nPeripheral mode interrupted. Returning to main menu.\")\n",
        "                        current_role = None # Return to main menu state\n",
        "                    else:\n",
        "                        print(f\"Unknown role: {role}. Use 'central' or 'peripheral'.\")\n",
        "                else:\n",
        "                    print(\"Usage: role [central | peripheral]\")\n",
        "\n",
        "            elif command == \"help\":\n",
        "                print_usage()\n",
        "\n",
        "            elif command == \"exit\":\n",
        "                print(\"Exiting application.\")\n",
        "                break\n",
        "\n",
        "            else:\n",
        "                print(f\"Unknown command: {command}. Available: role, help, exit\")\n",
        "\n",
        "        except EOFError:\n",
        "            print(\"\\nExiting application.\")\n",
        "            break\n",
        "        except Exception as e:\n",
        "             print(f\"\\nAn unexpected error occurred in the main loop: {e}\")\n",
        "             import traceback\n",
        "             traceback.print_exc()\n",
        "\n",
        "\n",
        "if __name__ == \"__main__\":\n",
        "    main()"
      ],
      "outputs": [],
      "execution_count": null,
      "metadata": {
        "id": "yiNxj2iML0QJ"
      }
    },
    {
      "cell_type": "markdown",
      "source": [
        "***\n",
        "\n",
        "### `README.md`\n",
        "\n",
        "```markdown\n",
        "# BLE Throughput Tester\n",
        "\n",
        "This Python command-line application measures BLE (Bluetooth Low Energy) throughput between two Linux devices using the BlueZ D-Bus API via `pydbus`. It supports both Central and Peripheral roles.\n",
        "\n",
        "## Features\n",
        "\n",
        "* **Dual Roles:** Operates as either a BLE Central or Peripheral device.\n",
        "* **Interactive CLI:** Provides commands to manage roles, devices, and tests.\n",
        "* **BlueZ Integration:** Uses native D-Bus interfaces provided by BlueZ.\n",
        "* **Throughput Test:** Measures data transfer speed using GATT Write operations (specifically Write Without Response for maximum speed).\n",
        "* **Device Discovery (Central):** Scans and lists paired BLE devices.\n",
        "* **Service/Characteristic Discovery (Central):** Lists GATT services and characteristics of a connected peripheral.\n",
        "* **GATT Server (Peripheral):** Registers a GATT service with a writable characteristic to receive data.\n",
        "* **Asynchronous Operations:** Uses `asyncio` for Central mode and `GLib` main loop for Peripheral mode.\n",
        "\n",
        "## Requirements\n",
        "\n",
        "* **Operating System:** Linux with BlueZ and D-Bus support.\n",
        "* **Python:** Python 3.7+ recommended.\n",
        "* **Dependencies:**\n",
        "    * `pydbus`: For D-Bus communication.\n",
        "    * `PyGObject` (python3-gi): Provides GLib integration needed for the peripheral's D-Bus service.\n",
        "* **Hardware:** Two Linux devices with Bluetooth adapters supporting BLE.\n",
        "\n",
        "## Installation\n",
        "\n",
        "1.  **Install BlueZ:**\n",
        "    Most modern Linux distributions come with BlueZ. Ensure it's installed and the `bluetoothd` service is running. You might need tools like `bluetoothctl`.\n",
        "    ```bash\n",
        "    # Debian/Ubuntu\n",
        "    sudo apt update\n",
        "    sudo apt install bluez python3-bluez # python3-bluez might not be strictly needed but good to have\n",
        "\n",
        "    # Fedora\n",
        "    sudo dnf install bluez bluez-libs bluez-tools\n",
        "\n",
        "    # Arch Linux\n",
        "    sudo pacman -S bluez bluez-utils\n",
        "    ```\n",
        "    Enable and start the Bluetooth service:\n",
        "    ```bash\n",
        "    sudo systemctl enable bluetooth.service\n",
        "    sudo systemctl start bluetooth.service\n",
        "    ```\n",
        "\n",
        "2.  **Install Python Dependencies:**\n",
        "    ```bash\n",
        "    # Install pydbus via pip\n",
        "    pip install pydbus\n",
        "\n",
        "    # Install PyGObject system-wide (recommended)\n",
        "    # Debian/Ubuntu\n",
        "    sudo apt install python3-gi python3-gi-cairo gir1.2-gtk-3.0\n",
        "\n",
        "    # Fedora\n",
        "    sudo dnf install python3-gobject gtk3\n",
        "\n",
        "    # Arch Linux\n",
        "    sudo pacman -S python-gobject gtk3\n",
        "    ```\n",
        "    *Note: Using a virtual environment (`venv`) is generally recommended for Python projects, but system-wide installation of `PyGObject` is often easier.*\n",
        "\n",
        "3.  **Download the Code:**\n",
        "    Save the provided Python files (`cli.py`, `central.py`, `peripheral.py`, `constants.py`, `utils.py`) into a single directory.\n",
        "\n",
        "## Usage\n",
        "\n",
        "You need two Linux devices. One will run as the peripheral, and the other as the central.\n",
        "\n",
        "**Device 1: Peripheral Role**\n",
        "\n",
        "1.  Navigate to the directory containing the scripts.\n",
        "2.  Start the peripheral:\n",
        "    ```bash\n",
        "    python3 cli.py peripheral\n",
        "    ```\n",
        "    Alternatively, use the interactive mode:\n",
        "    ```bash\n",
        "    python3 cli.py\n",
        "    Main Menu > role peripheral\n",
        "    ```\n",
        "3.  The script will register the GATT service and start advertising as \"BLE\\_Throughput\\_Test\". It will wait for a central device to connect and write data to the characteristic (`0000ff01-...`). Progress will be printed as data is received.\n",
        "4.  Press `Ctrl+C` to stop the peripheral.\n",
        "\n",
        "**Device 2: Central Role**\n",
        "\n",
        "1.  **Pairing (Important!):** Before running the test, you *must* pair the Central device with the Peripheral device using standard Linux Bluetooth tools (like `bluetoothctl`, GNOME/KDE Bluetooth settings). The central script currently lists and connects to *paired* devices.\n",
        "    * On the Central device, run `bluetoothctl`.\n",
        "    * `scan on` (Wait for \"BLE\\_Throughput\\_Test\" to appear)\n",
        "    * `pair XX:XX:XX:XX:XX:XX` (Replace with the peripheral's MAC address)\n",
        "    * `trust XX:XX:XX:XX:XX:XX`\n",
        "    * `scan off`\n",
        "    * `exit`\n",
        "\n",
        "2.  Navigate to the directory containing the scripts on the Central device.\n",
        "3.  Start the central role:\n",
        "    ```bash\n",
        "    python3 cli.py central\n",
        "    ```\n",
        "    Alternatively, use the interactive mode:\n",
        "    ```bash\n",
        "    python3 cli.py\n",
        "    Main Menu > role central\n",
        "    ```\n",
        "4.  Use the Central Mode commands:\n",
        "    * `list`: Shows paired devices. Enter the index number of the \"BLE\\_Throughput\\_Test\" peripheral to select it. If a device is already selected, it lists its services/characteristics.\n",
        "    * `select`: Allows re-selecting a different paired device.\n",
        "    * `run`: Starts the 5-second throughput test, writing data to the selected peripheral's target characteristic (`0000ff01-...`). It calculates and prints the approximate speed in kbps.\n",
        "    * `exit`: Exits Central mode (returns to the main menu in interactive mode or quits if started directly).\n",
        "\n",
        "**Example Workflow:**\n",
        "\n",
        "* **Peripheral:** `python3 cli.py peripheral`\n",
        "* **Central:** Pair using `bluetoothctl`.\n",
        "* **Central:** `python3 cli.py central`\n",
        "* **Central CLI:**\n",
        "    ```\n",
        "    Central Mode > list\n",
        "    # (Output shows paired devices, e.g., 0: BLE_Throughput_Test (AA:BB:CC:DD:EE:FF))\n",
        "    Select device index to connect: 0\n",
        "    Central Mode > run\n",
        "    # (Output shows test progress and final throughput)\n",
        "    Central Mode > exit\n",
        "    ```\n",
        "\n",
        "## Troubleshooting\n",
        "\n",
        "* **Adapter Not Found:** Ensure the Bluetooth adapter is enabled and `bluetoothd` is running (`sudo systemctl status bluetooth`).\n",
        "* **Permission Denied (D-Bus):** You might need to run the script with `sudo` or configure D-Bus permissions, although `pydbus.SystemBus()` usually works for user sessions that have Bluetooth access.\n",
        "* **Connection Failed:** Ensure devices are paired, within range, and the peripheral script is running. Check `dmesg` or `journalctl -f -u bluetooth.service` for lower-level BlueZ errors.\n",
        "* **Characteristic Not Found:** Verify the peripheral is advertising the correct `SERVICE_UUID` (`0000ffff-...`) and includes the `CHARACTERISTIC_UUID` (`0000ff01-...`). Allow some time after connection for service discovery.\n",
        "* **Slow Speeds:** BLE throughput depends heavily on distance, interference, adapter quality, and driver/BlueZ versions. The `PACKET_SIZE` (244 bytes) is near the theoretical maximum for Write Without Response on common MTU sizes, but actual speeds will be lower.\n",
        "```"
      ],
      "metadata": {
        "id": "kjSc2ZKwL0QM"
      }
    },
    {
      "cell_type": "markdown",
      "source": [
        "<div class=\"md-recitation\">\n",
        "  Sources\n",
        "  <ol>\n",
        "  <li><a href=\"https://discuss.python.org/t/need-to-create-a-new-variable-based-on-2-others/53858\">https://discuss.python.org/t/need-to-create-a-new-variable-based-on-2-others/53858</a></li>\n",
        "  <li><a href=\"https://stackoverflow.com/questions/50378547/python-bluez-gatt-server-client-cannot-disconnect\">https://stackoverflow.com/questions/50378547/python-bluez-gatt-server-client-cannot-disconnect</a></li>\n",
        "  <li><a href=\"https://github.com/z1mEk/CamPanel2\">https://github.com/z1mEk/CamPanel2</a></li>\n",
        "  <li><a href=\"https://github.com/pidash/PiDash\">https://github.com/pidash/PiDash</a></li>\n",
        "  <li><a href=\"https://github.com/DataForUs-udes/rasp-pi\">https://github.com/DataForUs-udes/rasp-pi</a></li>\n",
        "  </ol>\n",
        "</div>"
      ],
      "metadata": {
        "id": "37a8wFNYL0QO"
      }
    }
  ],
  "metadata": {
    "colab": {
      "provenance": [],
      "include_colab_link": true
    },
    "kernelspec": {
      "display_name": "Python 3",
      "name": "python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 0
}